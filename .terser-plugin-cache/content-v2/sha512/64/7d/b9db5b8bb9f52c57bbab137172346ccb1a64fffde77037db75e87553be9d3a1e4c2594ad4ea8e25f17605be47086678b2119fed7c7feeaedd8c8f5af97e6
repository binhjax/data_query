{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[57],{4695:function(e,t,n){\"use strict\";n.d(t,\"b\",(function(){return f})),n.d(t,\"c\",(function(){return v})),n.d(t,\"a\",(function(){return h}));var i=n(4727),o=n.n(i);function r(e){if(e=e&&e.positions||e,!Array.isArray(e)&&!ArrayBuffer.isView(e))throw new Error(\"invalid polygon\")}function s(e){return e.length>=1&&e[0].length>=2&&Number.isFinite(e[0][0])}function a(e){var t=e[0],n=e[e.length-1];return t[0]===n[0]&&t[1]===n[1]&&t[2]===n[2]}function l(e,t,n,i){for(var o=0;o<t;o++)if(e[n+o]!==e[i-t+o])return!1;return!0}function c(e,t,n,i){for(var o=t,r=n.length,s=0;s<r;s++)for(var l=0;l<i;l++)e[o++]=n[s][l]||0;if(!a(n))for(var c=0;c<i;c++)e[o++]=n[0][c]||0;return o}function u(e,t,n,i){var o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,r=arguments.length>5?arguments[5]:void 0,s=(r=r||n.length)-o;if(s<=0)return t;for(var a=t,c=0;c<s;c++)e[a++]=n[o+c];if(!l(n,i,o,r))for(var u=0;u<i;u++)e[a++]=n[o+u];return a}function p(e){return(a(e)?0:1)+e.length}function d(e,t){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,i=arguments.length>3?arguments[3]:void 0;return n>=(i=i||e.length)?0:(l(e,t,n,i)?0:1)+(i-n)/t}function f(e,t){if(r(e),e.positions){var n=e,i=n.positions,o=n.holeIndices;if(o){for(var a=0,l=0;l<=o.length;l++)a+=d(e.positions,t,o[l-1],o[l]);return a}e=i}if(Number.isFinite(e[0]))return d(e,t);if(!s(e)){var c=0,u=!0,f=!1,v=void 0;try{for(var h,g=e[Symbol.iterator]();!(u=(h=g.next()).done);u=!0){c+=p(h.value)}}catch(e){f=!0,v=e}finally{try{u||null==g.return||g.return()}finally{if(f)throw v}}return c}return p(e)}function v(e,t,n){r(e),n=n||f(e,t);var i=new Float64Array(n*t),o=[];if(e.positions){var a=e,l=a.positions,p=a.holeIndices;if(p){for(var d=0,v=0;v<=p.length;v++)d=u(i,d,l,t,p[v-1],p[v]),o.push(d);return o.pop(),{positions:i,holeIndices:o}}e=l}if(Number.isFinite(e[0]))return u(i,0,e,t),{positions:i,holeIndices:null};if(!s(e)){var h=0,g=!0,y=!1,x=void 0;try{for(var P,m=e[Symbol.iterator]();!(g=(P=m.next()).done);g=!0){h=c(i,h,P.value,t),o.push(h)}}catch(e){y=!0,x=e}finally{try{g||null==m.return||m.return()}finally{if(y)throw x}}return o.pop(),{positions:i,holeIndices:o}}return c(i,0,e,t),{positions:i,holeIndices:null}}function h(e,t){var n=null;return e.holeIndices&&(n=e.holeIndices.map((function(e){return e/t}))),o()(e.positions,n,t)}},4700:function(e,t,n){\"use strict\";n.d(t,\"a\",(function(){return b}));var i=n(15),o=n(16),r=n(223),s=n(89),a=n(241),l=n(19),c=n(4692),u=n(4890),p=n(4788),d=n(4648),f=n(5113),v=d.a.Tesselator,h=f.a.fp64LowPart,g=function(e){function t(e){var n=e.data,o=e.getGeometry,a=e.positionFormat,l=e.fp64;return Object(i.a)(this,t),Object(r.a)(this,Object(s.a)(t).call(this,{data:n,getGeometry:o,fp64:l,positionFormat:a,attributes:{startPositions:{size:3},endPositions:{size:3},leftPositions:{size:3},rightPositions:{size:3},startEndPositions64XyLow:{size:4,fp64Only:!0},neighborPositions64XyLow:{size:4,fp64Only:!0}}}))}return Object(l.a)(t,e),Object(o.a)(t,[{key:\"get\",value:function(e){return this.attributes[e]}},{key:\"getGeometrySize\",value:function(e){return Math.max(0,this.getPathLength(e)-1)}},{key:\"updateGeometryAttributes\",value:function(e,t){var n=this.attributes,i=n.startPositions,o=n.endPositions,r=n.leftPositions,s=n.rightPositions,a=n.startEndPositions64XyLow,l=n.neighborPositions64XyLow,c=this.fp64,u=t.geometrySize+1;if(!(u<2))for(var p,d=this.isClosed(e),f=this.getPointOnPath(e,0),v=this.getPointOnPath(e,1),g=d?this.getPointOnPath(e,u-2):f,y=t.vertexStart,x=1;x<u;y++,x++)p=x+1<u?this.getPointOnPath(e,x+1):d?this.getPointOnPath(e,1):v,i[3*y]=f[0],i[3*y+1]=f[1],i[3*y+2]=f[2]||0,o[3*y]=v[0],o[3*y+1]=v[1],o[3*y+2]=v[2]||0,r[3*y]=g[0],r[3*y+1]=g[1],r[3*y+2]=g[2]||0,s[3*y]=p[0],s[3*y+1]=p[1],s[3*y+2]=p[2]||0,c&&(a[4*y]=h(f[0]),a[4*y+1]=h(f[1]),a[4*y+2]=h(v[0]),a[4*y+3]=h(v[1]),l[4*y]=h(g[0]),l[4*y+1]=h(g[1]),l[4*y+2]=h(p[0]),l[4*y+3]=h(p[1])),g=f,f=v,v=p}},{key:\"getPathLength\",value:function(e){return Number.isFinite(e[0])?e.length/this.positionSize:e.length}},{key:\"getPointOnPath\",value:function(e,t){if(Number.isFinite(e[0])){var n=this.positionSize;return[e[t*n],e[t*n+1],3===n?e[t*n+2]:0]}return e[t]}},{key:\"isClosed\",value:function(e){var t=this.getPathLength(e),n=this.getPointOnPath(e,0),i=this.getPointOnPath(e,t-1);return n[0]===i[0]&&n[1]===i[1]&&n[2]===i[2]}}]),t}(v),y=\"#define SHADER_NAME path-layer-fragment-shader\\n\\nprecision highp float;\\n\\nuniform float jointType;\\nuniform float miterLimit;\\nuniform float alignMode;\\n\\nvarying vec4 vColor;\\nvarying vec2 vCornerOffset;\\nvarying float vMiterLength;\\nvarying vec2 vDashArray;\\nvarying vec2 vPathPosition;\\nvarying float vPathLength;\\nfloat mod2(float a, float b) {\\n  return a - floor(a / b) * b;\\n}\\n\\nfloat round(float x) {\\n  return floor(x + 0.5);\\n}\\nbool dash_isFragInGap() {\\n  float solidLength = vDashArray.x;\\n  float gapLength = vDashArray.y;\\n\\n  float unitLength = solidLength + gapLength;\\n\\n  if (unitLength == 0.0) {\\n    return false;\\n  }\\n\\n  unitLength = mix(\\n    unitLength,\\n    vPathLength / round(vPathLength / unitLength),\\n    alignMode\\n  );\\n\\n  float offset = alignMode * solidLength / 2.0;\\n\\n  return gapLength > 0.0 &&\\n    vPathPosition.y >= 0.0 &&\\n    vPathPosition.y <= vPathLength &&\\n    mod2(vPathPosition.y + offset, unitLength) > solidLength;\\n}\\n\\nvoid main(void) {\\n  if (jointType > 0.0 && vMiterLength > 0.0 && length(vCornerOffset) > 1.0) {\\n    discard;\\n  }\\n  if (jointType == 0.0 && vMiterLength > miterLimit) {\\n    discard;\\n  }\\n  if (vColor.a == 0.0 || dash_isFragInGap()) {\\n    discard;\\n  }\\n  gl_FragColor = vColor;\\n  gl_FragColor = picking_filterHighlightColor(gl_FragColor);\\n  gl_FragColor = picking_filterPickingColor(gl_FragColor);\\n}\\n\",x=[0,0,0,255],P={widthUnits:\"meters\",widthScale:{type:\"number\",min:0,value:1},widthMinPixels:{type:\"number\",min:0,value:0},widthMaxPixels:{type:\"number\",min:0,value:Number.MAX_SAFE_INTEGER},rounded:!1,miterLimit:{type:\"number\",min:0,value:4},fp64:!1,dashJustified:!1,billboard:!1,getPath:{type:\"accessor\",value:function(e){return e.path}},getColor:{type:\"accessor\",value:x},getWidth:{type:\"accessor\",value:1},getDashArray:{type:\"accessor\",value:[0,0]}},m={enter:function(e,t){return t.length?t.subarray(t.length-e.length):e}},b=function(e){function t(){return Object(i.a)(this,t),Object(r.a)(this,Object(s.a)(t).apply(this,arguments))}return Object(l.a)(t,e),Object(o.a)(t,[{key:\"getShaders\",value:function(){return this.use64bitProjection()?{vs:\"\\n#define SHADER_NAME path-layer-vertex-shader-64\\n\\nattribute vec3 positions;\\n\\nattribute vec3 instanceStartPositions;\\nattribute vec3 instanceEndPositions;\\nattribute vec4 instanceStartEndPositions64xyLow;\\nattribute vec3 instanceLeftPositions;\\nattribute vec3 instanceRightPositions;\\nattribute vec4 instanceNeighborPositions64xyLow;\\nattribute float instanceStrokeWidths;\\nattribute vec4 instanceColors;\\nattribute vec3 instancePickingColors;\\nattribute vec2 instanceDashArrays;\\n\\nuniform float widthScale;\\nuniform float widthMinPixels;\\nuniform float widthMaxPixels;\\nuniform float jointType;\\nuniform float miterLimit;\\n\\nuniform float opacity;\\n\\nvarying vec4 vColor;\\nvarying vec2 vCornerOffset;\\nvarying float vMiterLength;\\nvarying vec2 vDashArray;\\nvarying vec2 vPathPosition;\\nvarying float vPathLength;\\n\\nconst float EPSILON = 0.001;\\n\\nfloat flipIfTrue(bool flag) {\\n  return -(float(flag) * 2. - 1.);\\n}\\n\\nvec3 lineJoin(vec2 prevPoint64[2], vec2 currPoint64[2], vec2 nextPoint64[2]) {\\n\\n  float widthPixels = clamp(project_size_to_pixel(instanceStrokeWidths * widthScale),\\n    widthMinPixels, widthMaxPixels) / 2.0;\\n  float width = project_pixel_size(widthPixels);\\n\\n  vec2 deltaA64[2];\\n  vec2 deltaB64[2];\\n\\n  vec2_sub_fp64(currPoint64, prevPoint64, deltaA64);\\n  vec2_sub_fp64(nextPoint64, currPoint64, deltaB64);\\n\\n  vec2 lengthA64 = vec2_length_fp64(deltaA64);\\n  vec2 lengthB64 = vec2_length_fp64(deltaB64);\\n\\n  vec2 deltaA = vec2(deltaA64[0].x, deltaA64[1].x);\\n  vec2 deltaB = vec2(deltaB64[0].x, deltaB64[1].x);\\n\\n  float lenA = lengthA64.x;\\n  float lenB = lengthB64.x;\\n\\n  vec2 offsetVec;\\n  float offsetScale;\\n  float offsetDirection;\\n  lenA = lenA / width > EPSILON ? lenA : 0.0;\\n  lenB = lenB / width > EPSILON ? lenB : 0.0;\\n  vec2 dirA = lenA > 0. ? deltaA / lenA : vec2(0.0, 0.0);\\n  vec2 dirB = lenB > 0. ? deltaB / lenB : vec2(0.0, 0.0);\\n\\n  vec2 perpA = vec2(-dirA.y, dirA.x);\\n  vec2 perpB = vec2(-dirB.y, dirB.x);\\n  vec2 tangent = vec2(dirA + dirB);\\n  tangent = length(tangent) > 0. ? normalize(tangent) : perpA;\\n  vec2 miterVec = vec2(-tangent.y, tangent.x);\\n  vec2 perp = mix(perpB, perpA, positions.x);\\n  float L = mix(lenB, lenA, positions.x);\\n  float sinHalfA = abs(dot(miterVec, perp));\\n  float cosHalfA = abs(dot(dirA, miterVec));\\n  bool turnsRight = dirA.x * dirB.y > dirA.y * dirB.x;\\n  float cornerPosition = mix(\\n    flipIfTrue(turnsRight == (positions.y > 0.0)),\\n    0.0,\\n    positions.z\\n  );\\n\\n  offsetScale = 1.0 / max(sinHalfA, EPSILON);\\n  cornerPosition *= float(cornerPosition <= 0.0 || sinHalfA < min(lenA, lenB) / width * cosHalfA);\\n  offsetScale = mix(\\n    offsetScale,\\n    min(offsetScale, L / width / max(cosHalfA, EPSILON)),\\n    float(cornerPosition < 0.0)\\n  );\\n\\n  vMiterLength = mix(\\n    offsetScale * cornerPosition,\\n    mix(offsetScale, 0.0, cornerPosition),\\n    step(0.0, cornerPosition)\\n  ) - sinHalfA * jointType;\\n  offsetDirection = mix(\\n    positions.y,\\n    mix(\\n      flipIfTrue(turnsRight),\\n      positions.y * flipIfTrue(turnsRight == (positions.x == 1.)),\\n      cornerPosition\\n    ),\\n    step(0.0, cornerPosition)\\n  );\\n  offsetVec = mix(miterVec, -tangent, step(0.5, cornerPosition));\\n  offsetScale = mix(offsetScale, 1.0 / max(cosHalfA, 0.001), step(0.5, cornerPosition));\\n  float isStartCap = step(lenA, 1.0e-5);\\n  float isEndCap = step(lenB, 1.0e-5);\\n  float isCap = max(isStartCap, isEndCap);\\n  cornerPosition = isCap * (1.0 - positions.z);\\n  offsetVec = mix(offsetVec, mix(dirB, perpB, cornerPosition), isStartCap);\\n  offsetVec = mix(offsetVec, mix(dirA, perpA, cornerPosition), isEndCap);\\n  offsetScale = mix(\\n    offsetScale,\\n    mix(4.0 * jointType, 1.0, cornerPosition),\\n    isCap\\n  );\\n  vMiterLength = mix(vMiterLength, 1.0 - cornerPosition, isCap);\\n\\n  offsetDirection = mix(\\n    offsetDirection,\\n    mix(flipIfTrue(isStartCap > 0.), positions.y, cornerPosition),\\n    isCap\\n  );\\n\\n  vCornerOffset = offsetVec * offsetDirection * offsetScale;\\n  vDashArray = instanceDashArrays;\\n  vPathLength = L / width;\\n  float isEnd = positions.x;\\n  vec2 offsetFromStartOfPath = mix(vCornerOffset, vCornerOffset + deltaA / width, isEnd);\\n  vec2 dir = mix(dirB, dirA, isEnd);\\n  vPathPosition = vec2(\\n    positions.y + positions.z * offsetDirection,\\n    dot(offsetFromStartOfPath, dir)\\n  );\\n\\n  return vec3(vCornerOffset * width, 0.0);\\n}\\n\\nvoid main() {\\n  vColor = vec4(instanceColors.rgb, instanceColors.a * opacity) / 255.;\\n  picking_setPickingColor(instancePickingColors);\\n\\n  float isEnd = positions.x;\\n\\n  vec3 currPosition = mix(instanceStartPositions, instanceEndPositions, isEnd);\\n  vec2 currPosition64xyLow = mix(instanceStartEndPositions64xyLow.xy, instanceStartEndPositions64xyLow.zw, isEnd);\\n  vec2 projected_curr_position[2];\\n  project_position_fp64(currPosition.xy, currPosition64xyLow, projected_curr_position);\\n  float projected_curr_position_z = project_size(currPosition.z);\\n\\n  vec3 prevPosition = mix(instanceLeftPositions, instanceStartPositions, isEnd);\\n  vec2 prevPosition64xyLow = mix(instanceNeighborPositions64xyLow.xy, instanceStartEndPositions64xyLow.xy, isEnd);\\n\\n  vec2 projected_prev_position[2];\\n  project_position_fp64(prevPosition.xy, prevPosition64xyLow, projected_prev_position);\\n  vec3 nextPosition = mix(instanceEndPositions, instanceRightPositions, isEnd);\\n  vec2 nextPosition64xyLow = mix(instanceStartEndPositions64xyLow.zw, instanceNeighborPositions64xyLow.zw, isEnd);\\n\\n  vec2 projected_next_position[2];\\n  project_position_fp64(nextPosition.xy, nextPosition64xyLow, projected_next_position);\\n\\n  vec3 pos = lineJoin(projected_prev_position, projected_curr_position, projected_next_position);\\n  vec2 vertex_pos_modelspace[4];\\n\\n  vertex_pos_modelspace[0] = sum_fp64(vec2(pos.x, 0.0), projected_curr_position[0]);\\n  vertex_pos_modelspace[1] = sum_fp64(vec2(pos.y, 0.0), projected_curr_position[1]);\\n  vertex_pos_modelspace[2] = vec2(pos.z + projected_curr_position_z, 0.0);\\n  vertex_pos_modelspace[3] = vec2(1.0, 0.0);\\n\\n  gl_Position = project_common_position_to_clipspace_fp64(vertex_pos_modelspace);\\n}\\n\",fs:y,modules:[\"project64\",\"picking\"]}:{vs:\"#define SHADER_NAME path-layer-vertex-shader\\n\\nattribute vec3 positions;\\n\\nattribute vec3 instanceStartPositions;\\nattribute vec3 instanceEndPositions;\\nattribute vec4 instanceStartEndPositions64xyLow;\\nattribute vec3 instanceLeftPositions;\\nattribute vec3 instanceRightPositions;\\nattribute vec4 instanceNeighborPositions64xyLow;\\nattribute float instanceStrokeWidths;\\nattribute vec4 instanceColors;\\nattribute vec3 instancePickingColors;\\nattribute vec2 instanceDashArrays;\\n\\nuniform float widthScale;\\nuniform float widthMinPixels;\\nuniform float widthMaxPixels;\\nuniform float jointType;\\nuniform float miterLimit;\\nuniform bool billboard;\\n\\nuniform float opacity;\\n\\nvarying vec4 vColor;\\nvarying vec2 vCornerOffset;\\nvarying float vMiterLength;\\nvarying vec2 vDashArray;\\nvarying vec2 vPathPosition;\\nvarying float vPathLength;\\n\\nconst float EPSILON = 0.001;\\nconst vec3 ZERO_OFFSET = vec3(0.0);\\n\\nfloat flipIfTrue(bool flag) {\\n  return -(float(flag) * 2. - 1.);\\n}\\nvec3 lineJoin(\\n  vec3 prevPoint, vec3 currPoint, vec3 nextPoint,\\n  float relativePosition, bool isEnd, bool isJoint,\\n  vec2 width\\n) {\\n  vec2 deltaA = (currPoint.xy - prevPoint.xy) / width;\\n  vec2 deltaB = (nextPoint.xy - currPoint.xy) / width;\\n\\n  float lenA = length(deltaA);\\n  float lenB = length(deltaB);\\n  lenA = lenA > EPSILON ? lenA : 0.0;\\n  lenB = lenB > EPSILON ? lenB : 0.0;\\n\\n  vec2 dirA = lenA > 0. ? normalize(deltaA) : vec2(0.0, 0.0);\\n  vec2 dirB = lenB > 0. ? normalize(deltaB) : vec2(0.0, 0.0);\\n\\n  vec2 perpA = vec2(-dirA.y, dirA.x);\\n  vec2 perpB = vec2(-dirB.y, dirB.x);\\n  vec2 tangent = vec2(dirA + dirB);\\n  tangent = length(tangent) > 0. ? normalize(tangent) : perpA;\\n  vec2 miterVec = vec2(-tangent.y, tangent.x);\\n  vec2 perp = isEnd ? perpA : perpB;\\n  float L = isEnd ? lenA : lenB;\\n  float sinHalfA = abs(dot(miterVec, perp));\\n  float cosHalfA = abs(dot(dirA, miterVec));\\n\\n  bool turnsRight = dirA.x * dirB.y > dirA.y * dirB.x;\\n\\n  float offsetScale = 1.0 / max(sinHalfA, EPSILON);\\n\\n  float cornerPosition = isJoint ?\\n    0.0 :\\n    flipIfTrue(turnsRight == (relativePosition > 0.0));\\n  cornerPosition *=\\n    float(cornerPosition <= 0.0 || sinHalfA < min(lenA, lenB) * cosHalfA);\\n  if (cornerPosition < 0.0) {\\n    offsetScale = min(offsetScale, L / max(cosHalfA, EPSILON));\\n  }\\n\\n  vMiterLength = cornerPosition >= 0.0 ?\\n    mix(offsetScale, 0.0, cornerPosition) :\\n    offsetScale * cornerPosition;\\n  vMiterLength -= sinHalfA * jointType;\\n\\n  float offsetDirection = mix(\\n    positions.y,\\n    mix(\\n      flipIfTrue(turnsRight),\\n      positions.y * flipIfTrue(turnsRight == (positions.x == 1.)),\\n      cornerPosition\\n    ),\\n    step(0.0, cornerPosition)\\n  );\\n\\n  vec2 offsetVec = mix(miterVec, -tangent, step(0.5, cornerPosition));\\n  offsetScale = mix(offsetScale, 1.0 / max(cosHalfA, 0.001), step(0.5, cornerPosition));\\n  bool isStartCap = step(0.0, -lenA) > 0.5;\\n  bool isEndCap = step(0.0, -lenB) > 0.5;\\n  bool isCap = isStartCap || isEndCap;\\n  cornerPosition = isCap ? (1.0 - positions.z) : 0.;\\n  if (isStartCap) {\\n    offsetVec = mix(dirB, perpB, cornerPosition);\\n  }\\n  if (isEndCap) {\\n    offsetVec = mix(dirA, perpA, cornerPosition);\\n  }\\n  if (isCap) {\\n    offsetScale = mix(4.0 * jointType, 1.0, cornerPosition);\\n    vMiterLength = 1.0 - cornerPosition;\\n    offsetDirection = mix(flipIfTrue(isStartCap), positions.y, cornerPosition);\\n  }\\n\\n  vCornerOffset = offsetVec * offsetDirection * offsetScale;\\n  vDashArray = instanceDashArrays;\\n  vPathLength = L;\\n  vec2 offsetFromStartOfPath = vCornerOffset;\\n  if (isEnd) {\\n    offsetFromStartOfPath += deltaA;\\n  }\\n  vec2 dir = isEnd ? dirA : dirB;\\n  vPathPosition = vec2(\\n    positions.y + positions.z * offsetDirection,\\n    dot(offsetFromStartOfPath, dir)\\n  );\\n\\n  return currPoint + vec3(vCornerOffset * width, 0.0);\\n}\\nvec3 lineJoin(vec3 prevPoint, vec3 currPoint, vec3 nextPoint) {\\n\\n  float relativePosition = positions.y;\\n  bool isEnd = positions.x > EPSILON;\\n  bool isJoint = positions.z > EPSILON;\\n\\n  vec2 widthPixels = vec2(clamp(project_size_to_pixel(instanceStrokeWidths * widthScale),\\n    widthMinPixels, widthMaxPixels) / 2.0);\\n\\n  return lineJoin(\\n    prevPoint, currPoint, nextPoint,\\n    relativePosition, isEnd, isJoint,\\n    billboard ? project_pixel_size_to_clipspace(widthPixels) : project_pixel_size(widthPixels)\\n  );\\n}\\nvoid clipLine(inout vec4 position, vec4 refPosition) {\\n  if (position.w < EPSILON) {\\n    float r = (EPSILON - refPosition.w) / (position.w - refPosition.w);\\n    position = refPosition + (position - refPosition) * r;\\n  }\\n}\\n\\nvoid main() {\\n  vColor = vec4(instanceColors.rgb, instanceColors.a * opacity) / 255.;\\n  picking_setPickingColor(instancePickingColors);\\n\\n  float isEnd = positions.x;\\n\\n  vec3 prevPosition = mix(instanceLeftPositions, instanceStartPositions, isEnd);\\n  vec2 prevPosition64xyLow = mix(instanceNeighborPositions64xyLow.xy, instanceStartEndPositions64xyLow.xy, isEnd);\\n\\n  vec3 currPosition = mix(instanceStartPositions, instanceEndPositions, isEnd);\\n  vec2 currPosition64xyLow = mix(instanceStartEndPositions64xyLow.xy, instanceStartEndPositions64xyLow.zw, isEnd);\\n\\n  vec3 nextPosition = mix(instanceEndPositions, instanceRightPositions, isEnd);\\n  vec2 nextPosition64xyLow = mix(instanceStartEndPositions64xyLow.zw, instanceNeighborPositions64xyLow.zw, isEnd);\\n\\n  if (billboard) {\\n    vec4 prevPositionScreen = project_position_to_clipspace(prevPosition, prevPosition64xyLow, ZERO_OFFSET);\\n    vec4 currPositionScreen = project_position_to_clipspace(currPosition, currPosition64xyLow, ZERO_OFFSET);\\n    vec4 nextPositionScreen = project_position_to_clipspace(nextPosition, nextPosition64xyLow, ZERO_OFFSET);\\n\\n    clipLine(prevPositionScreen, currPositionScreen);\\n    clipLine(nextPositionScreen, currPositionScreen);\\n    clipLine(currPositionScreen, mix(nextPositionScreen, prevPositionScreen, isEnd));\\n\\n    vec3 pos = lineJoin(\\n      prevPositionScreen.xyz / prevPositionScreen.w,\\n      currPositionScreen.xyz / currPositionScreen.w,\\n      nextPositionScreen.xyz / nextPositionScreen.w\\n    );\\n\\n    gl_Position = vec4(pos * currPositionScreen.w, currPositionScreen.w);\\n  } else {\\n    prevPosition = project_position(prevPosition, prevPosition64xyLow);\\n    currPosition = project_position(currPosition, currPosition64xyLow);\\n    nextPosition = project_position(nextPosition, nextPosition64xyLow);\\n\\n    vec3 pos = lineJoin(prevPosition, currPosition, nextPosition);\\n    gl_Position = project_common_position_to_clipspace(vec4(pos, 1.0));\\n  }\\n}\\n\",fs:y,modules:[\"project32\",\"picking\"]}}},{key:\"initializeState\",value:function(){var e=this;this.getAttributeManager().addInstanced({instanceStartPositions:{size:3,transition:m,accessor:\"getPath\",update:this.calculateStartPositions,noAlloc:!0},instanceEndPositions:{size:3,transition:m,accessor:\"getPath\",update:this.calculateEndPositions,noAlloc:!0},instanceStartEndPositions64xyLow:{size:4,update:this.calculateInstanceStartEndPositions64xyLow,noAlloc:!0},instanceLeftPositions:{size:3,accessor:\"getPath\",update:this.calculateLeftPositions,noAlloc:!0},instanceRightPositions:{size:3,accessor:\"getPath\",update:this.calculateRightPositions,noAlloc:!0},instanceNeighborPositions64xyLow:{size:4,update:this.calculateInstanceNeighborPositions64xyLow,noAlloc:!0},instanceStrokeWidths:{size:1,accessor:\"getWidth\",transition:m,defaultValue:1},instanceDashArrays:{size:2,accessor:\"getDashArray\"},instanceColors:{size:4,type:5121,accessor:\"getColor\",transition:m,defaultValue:x},instancePickingColors:{size:3,type:5121,accessor:function(t,n){var i=n.index,o=n.target;return e.encodePickingColor(i,o)}}}),this.setState({pathTesselator:new g({})})}},{key:\"updateState\",value:function(e){var n=e.oldProps,i=e.props,o=e.changeFlags;Object(a.a)(Object(s.a)(t.prototype),\"updateState\",this).call(this,{props:i,oldProps:n,changeFlags:o});var r=this.getAttributeManager();if(o.dataChanged||i.fp64!==n.fp64||o.updateTriggersChanged&&(o.updateTriggersChanged.all||o.updateTriggersChanged.getPath)){var l=this.state.pathTesselator;l.updateGeometry({data:i.data,getGeometry:i.getPath,positionFormat:i.positionFormat,fp64:this.use64bitPositions()}),this.setState({numInstances:l.instanceCount,bufferLayout:l.bufferLayout}),r.invalidateAll()}if(i.fp64!==n.fp64){var c=this.context.gl;this.state.model&&this.state.model.delete(),this.setState({model:this._getModel(c)}),r.invalidateAll()}}},{key:\"draw\",value:function(e){var t=e.uniforms,n=this.context.viewport,i=this.props,o=i.rounded,r=i.billboard,s=i.miterLimit,a=i.widthUnits,l=i.widthScale,c=i.widthMinPixels,u=i.widthMaxPixels,p=i.dashJustified,d=\"pixels\"===a?n.distanceScales.metersPerPixel[2]:1;this.state.model.setUniforms(Object.assign({},t,{jointType:Number(o),billboard:r,alignMode:Number(p),widthScale:l*d,miterLimit:s,widthMinPixels:c,widthMaxPixels:u})).draw()}},{key:\"_getModel\",value:function(e){return new u.a(e,Object.assign({},this.getShaders(),{id:this.props.id,geometry:new p.a({drawMode:4,attributes:{indices:new Uint16Array([0,2,1,1,2,4,1,4,3,3,4,5]),positions:new Float32Array([0,0,1,0,-1,0,0,1,0,1,-1,0,1,1,0,1,0,1])}}),isInstanced:!0,shaderCache:this.context.shaderCache}))}},{key:\"calculateStartPositions\",value:function(e){var t=this.state.pathTesselator;e.bufferLayout=t.bufferLayout,e.value=t.get(\"startPositions\")}},{key:\"calculateEndPositions\",value:function(e){var t=this.state.pathTesselator;e.bufferLayout=t.bufferLayout,e.value=t.get(\"endPositions\")}},{key:\"calculateInstanceStartEndPositions64xyLow\",value:function(e){var t=this.use64bitPositions();e.constant=!t,e.value=t?this.state.pathTesselator.get(\"startEndPositions64XyLow\"):new Float32Array(4)}},{key:\"calculateLeftPositions\",value:function(e){var t=this.state.pathTesselator;e.value=t.get(\"leftPositions\")}},{key:\"calculateRightPositions\",value:function(e){var t=this.state.pathTesselator;e.value=t.get(\"rightPositions\")}},{key:\"calculateInstanceNeighborPositions64xyLow\",value:function(e){var t=this.use64bitPositions();e.constant=!t,e.value=t?this.state.pathTesselator.get(\"neighborPositions64XyLow\"):new Float32Array(4)}},{key:\"clearPickingColor\",value:function(e){for(var t=this.decodePickingColor(e),n=this.state.pathTesselator.bufferLayout,i=n[t],o=0,r=0;r<t;r++)o+=n[r];var s=this.getAttributeManager().attributes.instancePickingColors,a=s.value,l=o+i;a.fill(0,3*o,3*l),s.update({value:a})}}]),t}(c.a);b.layerName=\"PathLayer\",b.defaultProps=P},4706:function(e,t,n){\"use strict\";n.d(t,\"a\",(function(){return d}));var i=n(15),o=n(16),r=n(223),s=n(89),a=n(241),l=n(19),c=n(4692),u=n(4655),p=n(4683),d=function(e){function t(){return Object(i.a)(this,t),Object(r.a)(this,Object(s.a)(t).apply(this,arguments))}return Object(l.a)(t,e),Object(o.a)(t,[{key:\"getSubLayers\",value:function(){return this.internalState&&this.internalState.subLayers||[]}},{key:\"initializeState\",value:function(){}},{key:\"setState\",value:function(e){Object(a.a)(Object(s.a)(t.prototype),\"setState\",this).call(this,e),this.setLayerNeedsUpdate()}},{key:\"getPickingInfo\",value:function(e){return e.info}},{key:\"renderLayers\",value:function(){return null}},{key:\"shouldRenderSubLayer\",value:function(e,t){var n=this.props._subLayerProps;return t&&t.length||n&&n[e]}},{key:\"getSubLayerClass\",value:function(e,t){var n=this.props._subLayerProps;return n&&n[e]&&n[e].type||t}},{key:\"getSubLayerProps\",value:function(e){var t=this.props,n=t.opacity,i=t.pickable,o=t.visible,r=t.parameters,s=t.getPolygonOffset,a=t.highlightedObjectIndex,l=t.autoHighlight,c=t.highlightColor,u=t.coordinateSystem,p=t.coordinateOrigin,d=t.wrapLongitude,f=t.positionFormat,v=t.modelMatrix,h=t._subLayerProps,g={opacity:n,pickable:i,visible:o,parameters:r,getPolygonOffset:s,highlightedObjectIndex:a,autoHighlight:l,highlightColor:c,coordinateSystem:u,coordinateOrigin:p,wrapLongitude:d,positionFormat:f,modelMatrix:v};if(e){var y=h&&h[e.id],x=y&&y.updateTriggers;Object.assign(g,e,y,{id:\"\".concat(this.props.id,\"-\").concat(e.id),updateTriggers:Object.assign({all:this.props.updateTriggers.all},e.updateTriggers,x)})}return g}},{key:\"_getAttributeManager\",value:function(){return null}},{key:\"_renderLayers\",value:function(){var e=this.internalState.subLayers;e&&!this.needsUpdate()?u.a.log(3,\"Composite layer reused subLayers \".concat(this),this.internalState.subLayers)():(e=this.renderLayers(),e=Object(p.b)(e,{filter:Boolean}),this.internalState.subLayers=e,u.a.log(2,\"Composite layer rendered new subLayers \".concat(this),e)());var t=!0,n=!1,i=void 0;try{for(var o,r=e[Symbol.iterator]();!(t=(o=r.next()).done);t=!0){o.value.parent=this}}catch(e){n=!0,i=e}finally{try{t||null==r.return||r.return()}finally{if(n)throw i}}}},{key:\"isComposite\",get:function(){return!0}}]),t}(c.a);d.layerName=\"CompositeLayer\"},4718:function(e,t,n){\"use strict\";n.d(t,\"a\",(function(){return k}));var i=n(15),o=n(16),r=n(223),s=n(89),a=n(241),l=n(19),c=n(4692),u=n(4763),p=n(5073),d=n(4947),f=n(4890),v=n(4788),h=n(4695),g=n(4648),y=n(5113),x=g.a.Tesselator,P=y.a.fp64LowPart,m=function(e){function t(e){var n=e.data,o=e.getGeometry,a=e.fp64,l=e.positionFormat,c=e.IndexType,u=void 0===c?Uint32Array:c;return Object(i.a)(this,t),Object(r.a)(this,Object(s.a)(t).call(this,{data:n,getGeometry:o,fp64:a,positionFormat:l,attributes:{positions:{size:3},positions64xyLow:{size:2,fp64Only:!0},vertexValid:{type:Uint8ClampedArray,size:1},indices:{type:u,size:1}}}))}return Object(l.a)(t,e),Object(o.a)(t,[{key:\"get\",value:function(e){return\"indices\"===e?this.attributes.indices.subarray(0,this.vertexCount):this.attributes[e]}},{key:\"getGeometrySize\",value:function(e){return h.b(e,this.positionSize)}},{key:\"updateGeometryAttributes\",value:function(e,t){e=h.c(e,this.positionSize,t.geometrySize),this._updateIndices(e,t),this._updatePositions(e,t)}},{key:\"_updateIndices\",value:function(e,t){var n=t.geometryIndex,i=t.vertexStart,o=t.indexStart,r=this.attributes,s=this.indexLayout,a=this.typedArrayManager,l=r.indices,c=l.length,u=o,p=h.a(e,this.positionSize);c<u+p.length&&(c=2*(u+p.length),l=a.allocate(l,c,{type:l.constructor,size:1,copy:!0}));for(var d=0;d<p.length;d++)l[u++]=p[d]+i;s[n]=p.length,r.indices=l}},{key:\"_updatePositions\",value:function(e,t){for(var n=t.vertexStart,i=t.geometrySize,o=this.attributes,r=o.positions,s=o.positions64xyLow,a=o.vertexValid,l=this.fp64,c=this.positionSize,u=n,p=e.positions,d=e.holeIndices,f=0;f<i;f++){var v=p[f*c],h=p[f*c+1],g=c>2?p[f*c+2]:0;r[3*u]=v,r[3*u+1]=h,r[3*u+2]=g,l&&(s[2*u]=P(v),s[2*u+1]=P(h)),a[u]=1,u++}if(d)for(var y=0;y<d.length;y++)a[n+d[y]/c-1]=0;a[n+i-1]=0}}]),t}(x),b=\"\\nattribute vec2 vertexPositions;\\nattribute float vertexValid;\\n\\nuniform bool extruded;\\nuniform bool isWireframe;\\nuniform float elevationScale;\\nuniform float opacity;\\n\\nvarying vec4 vColor;\\nvarying float isValid;\\n\\nstruct PolygonProps {\\n  vec4 fillColors;\\n  vec4 lineColors;\\n  vec3 positions;\\n  vec3 nextPositions;\\n  vec3 pickingColors;\\n  vec2 positions64xyLow;\\n  vec2 nextPositions64xyLow;\\n  float elevations;\\n};\\n\\nvec3 project_offset_normal(vec3 vector) {\\n  if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNG_LAT ||\\n    project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSETS ||\\n    project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT_AUTO_OFFSET) {\\n    return normalize(vector * project_uCommonUnitsPerWorldUnit);\\n  }\\n  return project_normal(vector);\\n}\\n\\nvoid calculatePosition(PolygonProps props) {\\n  vec3 pos;\\n  vec2 pos64xyLow;\\n  vec3 normal;\\n  vec4 colors = isWireframe ? props.lineColors : props.fillColors;\\n\\n#ifdef IS_SIDE_VERTEX\\n  pos = mix(props.positions, props.nextPositions, vertexPositions.x);\\n  pos64xyLow = mix(props.positions64xyLow, props.nextPositions64xyLow, vertexPositions.x);\\n  isValid = vertexValid;\\n#else\\n  pos = props.positions;\\n  pos64xyLow = props.positions64xyLow;\\n  isValid = 1.0;\\n#endif\\n\\n  if (extruded) {\\n    pos.z += props.elevations * vertexPositions.y * elevationScale;\\n  }\\n\\n  vec4 position_commonspace;\\n  gl_Position = project_position_to_clipspace(pos, pos64xyLow, vec3(0.), position_commonspace);\\n\\n  if (extruded) {\\n#ifdef IS_SIDE_VERTEX\\n    normal = vec3(props.positions.y - props.nextPositions.y, props.nextPositions.x - props.positions.x, 0.0);\\n    normal = project_offset_normal(normal);\\n#else\\n    normal = vec3(0.0, 0.0, 1.0);\\n#endif\\n\\n    vec3 lightColor = lighting_getLightColor(colors.rgb, project_uCameraPosition, position_commonspace.xyz, normal);\\n    vColor = vec4(lightColor, colors.a * opacity) / 255.0;\\n  } else {\\n    vColor = vec4(colors.rgb, colors.a * opacity) / 255.0;\\n  }\\n  picking_setPickingColor(props.pickingColors);\\n}\\n\",L=\"#define SHADER_NAME solid-polygon-layer-vertex-shader\\n\\nattribute vec3 positions;\\nattribute vec2 positions64xyLow;\\nattribute float elevations;\\nattribute vec4 fillColors;\\nattribute vec4 lineColors;\\nattribute vec3 pickingColors;\\n\\n\".concat(b,\"\\n\\nvoid main(void) {\\n  PolygonProps props;\\n\\n  props.positions = positions;\\n  props.positions64xyLow = positions64xyLow;\\n  props.elevations = elevations;\\n  props.fillColors = fillColors;\\n  props.lineColors = lineColors;\\n  props.pickingColors = pickingColors;\\n\\n  calculatePosition(props);\\n}\\n\"),C=\"#define SHADER_NAME solid-polygon-layer-vertex-shader-side\\n#define IS_SIDE_VERTEX\\n\\n\\nattribute vec3 instancePositions;\\nattribute vec2 instancePositions64xyLow;\\nattribute vec3 nextPositions;\\nattribute vec2 nextPositions64xyLow;\\nattribute float instanceElevations;\\nattribute vec4 instanceFillColors;\\nattribute vec4 instanceLineColors;\\nattribute vec3 instancePickingColors;\\n\\n\".concat(b,\"\\n\\nvoid main(void) {\\n  PolygonProps props;\\n\\n  props.positions = instancePositions;\\n  props.positions64xyLow = instancePositions64xyLow;\\n  props.elevations = instanceElevations;\\n  props.fillColors = instanceFillColors;\\n  props.lineColors = instanceLineColors;\\n  props.pickingColors = instancePickingColors;\\n  props.nextPositions = nextPositions;\\n  props.nextPositions64xyLow = nextPositions64xyLow;\\n\\n  calculatePosition(props);\\n}\\n\"),S=[0,0,0,255],w=new u.a,_={filled:!0,extruded:!1,wireframe:!1,fp64:!1,elevationScale:{type:\"number\",min:0,value:1},getPolygon:{type:\"accessor\",value:function(e){return e.polygon}},getElevation:{type:\"accessor\",value:1e3},getFillColor:{type:\"accessor\",value:S},getLineColor:{type:\"accessor\",value:S},material:w},A={enter:function(e,t){return t.length?t.subarray(t.length-e.length):e}},k=function(e){function t(){return Object(i.a)(this,t),Object(r.a)(this,Object(s.a)(t).apply(this,arguments))}return Object(l.a)(t,e),Object(o.a)(t,[{key:\"getShaders\",value:function(e){return{vs:e,fs:\"#define SHADER_NAME solid-polygon-layer-fragment-shader\\n\\nprecision highp float;\\n\\nvarying vec4 vColor;\\nvarying float isValid;\\n\\nvoid main(void) {\\n  if (isValid < 0.5) {\\n    discard;\\n  }\\n\\n  gl_FragColor = vColor;\\n  gl_FragColor = picking_filterHighlightColor(gl_FragColor);\\n  gl_FragColor = picking_filterPickingColor(gl_FragColor);\\n}\\n\",defines:{},modules:[this.use64bitProjection()?\"project64\":\"project32\",\"gouraud-lighting\",\"picking\"]}}},{key:\"initializeState\",value:function(){var e=this,t=this.context.gl;this.setState({numInstances:0,polygonTesselator:new m({IndexType:!t||Object(p.b)(t,d.a.ELEMENT_INDEX_UINT32)?Uint32Array:Uint16Array})});var n=this.getAttributeManager();n.remove([\"instancePickingColors\"]),n.add({indices:{size:1,isIndexed:!0,update:this.calculateIndices,noAlloc:!0},positions:{size:3,transition:A,accessor:\"getPolygon\",update:this.calculatePositions,noAlloc:!0,shaderAttributes:{positions:{offset:0,divisor:0},instancePositions:{offset:0,divisor:1},nextPositions:{offset:12,divisor:1}}},positions64xyLow:{size:2,update:this.calculatePositionsLow,noAlloc:!0,shaderAttributes:{positions64xyLow:{offset:0,divisor:0},instancePositions64xyLow:{offset:0,divisor:1},nextPositions64xyLow:{offset:8,divisor:1}}},vertexValid:{size:1,divisor:1,type:5121,update:this.calculateVertexValid,noAlloc:!0},elevations:{size:1,transition:A,accessor:\"getElevation\",shaderAttributes:{elevations:{divisor:0},instanceElevations:{divisor:1}}},fillColors:{alias:\"colors\",size:4,type:5121,transition:A,accessor:\"getFillColor\",defaultValue:S,shaderAttributes:{fillColors:{divisor:0},instanceFillColors:{divisor:1}}},lineColors:{alias:\"colors\",size:4,type:5121,transition:A,accessor:\"getLineColor\",defaultValue:S,shaderAttributes:{lineColors:{divisor:0},instanceLineColors:{divisor:1}}},pickingColors:{size:3,type:5121,accessor:function(t,n){var i=n.index,o=n.target;return e.encodePickingColor(i,o)},shaderAttributes:{pickingColors:{divisor:0},instancePickingColors:{divisor:1}}}})}},{key:\"draw\",value:function(e){var t=e.uniforms,n=this.props,i=n.extruded,o=n.filled,r=n.wireframe,s=n.elevationScale,a=this.state,l=a.topModel,c=a.sideModel,u=a.polygonTesselator,p=Object.assign({},t,{extruded:Boolean(i),elevationScale:s});c&&(c.setInstanceCount(u.instanceCount-1),c.setUniforms(p),r&&(c.setDrawMode(3),c.setUniforms({isWireframe:!0}).draw()),o&&(c.setDrawMode(6),c.setUniforms({isWireframe:!1}).draw())),l&&(l.setVertexCount(u.get(\"indices\").length),l.setUniforms(p).draw())}},{key:\"updateState\",value:function(e){Object(a.a)(Object(s.a)(t.prototype),\"updateState\",this).call(this,e),this.updateGeometry(e);var n=e.props,i=e.oldProps,o=this.getAttributeManager();(n.fp64!==i.fp64||n.filled!==i.filled||n.extruded!==i.extruded)&&(this.state.models&&this.state.models.forEach((function(e){return e.delete()})),this.setState(this._getModels(this.context.gl)),o.invalidateAll())}},{key:\"updateGeometry\",value:function(e){var t=e.props,n=e.oldProps,i=e.changeFlags;if(i.dataChanged||t.fp64!==n.fp64||i.updateTriggersChanged&&(i.updateTriggersChanged.all||i.updateTriggersChanged.getPolygon)){var o=this.state.polygonTesselator;o.updateGeometry({data:t.data,getGeometry:t.getPolygon,positionFormat:t.positionFormat,fp64:this.use64bitPositions()}),this.setState({numInstances:o.instanceCount,bufferLayout:o.bufferLayout}),this.getAttributeManager().invalidateAll()}}},{key:\"_getModels\",value:function(e){var t,n,i=this.props,o=i.id,r=i.filled,s=i.extruded;if(r){var a=this.getShaders(L);a.defines.NON_INSTANCED_MODEL=1,t=new f.a(e,Object.assign({},a,{id:\"\".concat(o,\"-top\"),drawMode:4,attributes:{vertexPositions:new Float32Array([0,1])},uniforms:{isWireframe:!1,isSideVertex:!1},vertexCount:0,isIndexed:!0,shaderCache:this.context.shaderCache}))}return s&&((n=new f.a(e,Object.assign({},this.getShaders(C),{id:\"\".concat(o,\"-side\"),geometry:new v.a({drawMode:1,vertexCount:4,attributes:{vertexPositions:{size:2,value:new Float32Array([1,1,0,1,0,0,1,0])}}}),instanceCount:0,isInstanced:1,shaderCache:this.context.shaderCache}))).userData.excludeAttributes={indices:!0}),{models:[n,t].filter(Boolean),topModel:t,sideModel:n}}},{key:\"calculateIndices\",value:function(e){var t=this.state.polygonTesselator;e.bufferLayout=t.indexLayout,e.value=t.get(\"indices\")}},{key:\"calculatePositions\",value:function(e){var t=this.state.polygonTesselator;e.bufferLayout=t.bufferLayout,e.value=t.get(\"positions\")}},{key:\"calculatePositionsLow\",value:function(e){var t=this.use64bitPositions();e.constant=!t,e.value=t?this.state.polygonTesselator.get(\"positions64xyLow\"):new Float32Array(2)}},{key:\"calculateVertexValid\",value:function(e){e.value=this.state.polygonTesselator.get(\"vertexValid\")}},{key:\"clearPickingColor\",value:function(e){for(var t=this.decodePickingColor(e),n=this.state.polygonTesselator.bufferLayout,i=n[t],o=0,r=0;r<t;r++)o+=n[r];var s=this.getAttributeManager().attributes.pickingColors,a=s.value,l=o+i;a.fill(0,3*o,3*l),s.update({value:a})}}]),t}(c.a);k.layerName=\"SolidPolygonLayer\",k.defaultProps=_},4727:function(e,t,n){\"use strict\";function i(e,t,n){n=n||2;var i,a,l,c,u,f,v,g=t&&t.length,y=g?t[0]*n:e.length,x=o(e,0,y,n,!0),P=[];if(!x||x.next===x.prev)return P;if(g&&(x=function(e,t,n,i){var s,a,l,c,u,f=[];for(s=0,a=t.length;s<a;s++)l=t[s]*i,c=s<a-1?t[s+1]*i:e.length,(u=o(e,l,c,i,!1))===u.next&&(u.steiner=!0),f.push(h(u));for(f.sort(p),s=0;s<f.length;s++)d(f[s],n),n=r(n,n.next);return n}(e,t,x,n)),e.length>80*n){i=l=e[0],a=c=e[1];for(var m=n;m<y;m+=n)(u=e[m])<i&&(i=u),(f=e[m+1])<a&&(a=f),u>l&&(l=u),f>c&&(c=f);v=0!==(v=Math.max(l-i,c-a))?1/v:0}return s(x,P,n,i,a,v),P}function o(e,t,n,i,o){var r,s;if(o===k(e,t,n,i)>0)for(r=t;r<n;r+=i)s=w(r,e[r],e[r+1],s);else for(r=n-i;r>=t;r-=i)s=w(r,e[r],e[r+1],s);return s&&P(s,s.next)&&(_(s),s=s.next),s}function r(e,t){if(!e)return e;t||(t=e);var n,i=e;do{if(n=!1,i.steiner||!P(i,i.next)&&0!==x(i.prev,i,i.next))i=i.next;else{if(_(i),(i=t=i.prev)===i.next)break;n=!0}}while(n||i!==t);return t}function s(e,t,n,i,o,p,d){if(e){!d&&p&&function(e,t,n,i){var o=e;do{null===o.z&&(o.z=v(o.x,o.y,t,n,i)),o.prevZ=o.prev,o.nextZ=o.next,o=o.next}while(o!==e);o.prevZ.nextZ=null,o.prevZ=null,function(e){var t,n,i,o,r,s,a,l,c=1;do{for(n=e,e=null,r=null,s=0;n;){for(s++,i=n,a=0,t=0;t<c&&(a++,i=i.nextZ);t++);for(l=c;a>0||l>0&&i;)0!==a&&(0===l||!i||n.z<=i.z)?(o=n,n=n.nextZ,a--):(o=i,i=i.nextZ,l--),r?r.nextZ=o:e=o,o.prevZ=r,r=o;n=i}r.nextZ=null,c*=2}while(s>1)}(o)}(e,i,o,p);for(var f,h,g=e;e.prev!==e.next;)if(f=e.prev,h=e.next,p?l(e,i,o,p):a(e))t.push(f.i/n),t.push(e.i/n),t.push(h.i/n),_(e),e=h.next,g=h.next;else if((e=h)===g){d?1===d?s(e=c(r(e),t,n),t,n,i,o,p,2):2===d&&u(e,t,n,i,o,p):s(r(e),t,n,i,o,p,1);break}}}function a(e){var t=e.prev,n=e,i=e.next;if(x(t,n,i)>=0)return!1;for(var o=e.next.next;o!==e.prev;){if(g(t.x,t.y,n.x,n.y,i.x,i.y,o.x,o.y)&&x(o.prev,o,o.next)>=0)return!1;o=o.next}return!0}function l(e,t,n,i){var o=e.prev,r=e,s=e.next;if(x(o,r,s)>=0)return!1;for(var a=o.x<r.x?o.x<s.x?o.x:s.x:r.x<s.x?r.x:s.x,l=o.y<r.y?o.y<s.y?o.y:s.y:r.y<s.y?r.y:s.y,c=o.x>r.x?o.x>s.x?o.x:s.x:r.x>s.x?r.x:s.x,u=o.y>r.y?o.y>s.y?o.y:s.y:r.y>s.y?r.y:s.y,p=v(a,l,t,n,i),d=v(c,u,t,n,i),f=e.prevZ,h=e.nextZ;f&&f.z>=p&&h&&h.z<=d;){if(f!==e.prev&&f!==e.next&&g(o.x,o.y,r.x,r.y,s.x,s.y,f.x,f.y)&&x(f.prev,f,f.next)>=0)return!1;if(f=f.prevZ,h!==e.prev&&h!==e.next&&g(o.x,o.y,r.x,r.y,s.x,s.y,h.x,h.y)&&x(h.prev,h,h.next)>=0)return!1;h=h.nextZ}for(;f&&f.z>=p;){if(f!==e.prev&&f!==e.next&&g(o.x,o.y,r.x,r.y,s.x,s.y,f.x,f.y)&&x(f.prev,f,f.next)>=0)return!1;f=f.prevZ}for(;h&&h.z<=d;){if(h!==e.prev&&h!==e.next&&g(o.x,o.y,r.x,r.y,s.x,s.y,h.x,h.y)&&x(h.prev,h,h.next)>=0)return!1;h=h.nextZ}return!0}function c(e,t,n){var i=e;do{var o=i.prev,s=i.next.next;!P(o,s)&&m(o,i,i.next,s)&&C(o,s)&&C(s,o)&&(t.push(o.i/n),t.push(i.i/n),t.push(s.i/n),_(i),_(i.next),i=e=s),i=i.next}while(i!==e);return r(i)}function u(e,t,n,i,o,a){var l=e;do{for(var c=l.next.next;c!==l.prev;){if(l.i!==c.i&&y(l,c)){var u=S(l,c);return l=r(l,l.next),u=r(u,u.next),s(l,t,n,i,o,a),void s(u,t,n,i,o,a)}c=c.next}l=l.next}while(l!==e)}function p(e,t){return e.x-t.x}function d(e,t){if(t=function(e,t){var n,i=t,o=e.x,r=e.y,s=-1/0;do{if(r<=i.y&&r>=i.next.y&&i.next.y!==i.y){var a=i.x+(r-i.y)*(i.next.x-i.x)/(i.next.y-i.y);if(a<=o&&a>s){if(s=a,a===o){if(r===i.y)return i;if(r===i.next.y)return i.next}n=i.x<i.next.x?i:i.next}}i=i.next}while(i!==t);if(!n)return null;if(o===s)return n;var l,c=n,u=n.x,p=n.y,d=1/0;i=n;do{o>=i.x&&i.x>=u&&o!==i.x&&g(r<p?o:s,r,u,p,r<p?s:o,r,i.x,i.y)&&(l=Math.abs(r-i.y)/(o-i.x),C(i,e)&&(l<d||l===d&&(i.x>n.x||i.x===n.x&&f(n,i)))&&(n=i,d=l)),i=i.next}while(i!==c);return n}(e,t)){var n=S(t,e);r(t,t.next),r(n,n.next)}}function f(e,t){return x(e.prev,e,t.prev)<0&&x(t.next,e,e.next)<0}function v(e,t,n,i,o){return(e=1431655765&((e=858993459&((e=252645135&((e=16711935&((e=32767*(e-n)*o)|e<<8))|e<<4))|e<<2))|e<<1))|(t=1431655765&((t=858993459&((t=252645135&((t=16711935&((t=32767*(t-i)*o)|t<<8))|t<<4))|t<<2))|t<<1))<<1}function h(e){var t=e,n=e;do{(t.x<n.x||t.x===n.x&&t.y<n.y)&&(n=t),t=t.next}while(t!==e);return n}function g(e,t,n,i,o,r,s,a){return(o-s)*(t-a)-(e-s)*(r-a)>=0&&(e-s)*(i-a)-(n-s)*(t-a)>=0&&(n-s)*(r-a)-(o-s)*(i-a)>=0}function y(e,t){return e.next.i!==t.i&&e.prev.i!==t.i&&!function(e,t){var n=e;do{if(n.i!==e.i&&n.next.i!==e.i&&n.i!==t.i&&n.next.i!==t.i&&m(n,n.next,e,t))return!0;n=n.next}while(n!==e);return!1}(e,t)&&(C(e,t)&&C(t,e)&&function(e,t){var n=e,i=!1,o=(e.x+t.x)/2,r=(e.y+t.y)/2;do{n.y>r!=n.next.y>r&&n.next.y!==n.y&&o<(n.next.x-n.x)*(r-n.y)/(n.next.y-n.y)+n.x&&(i=!i),n=n.next}while(n!==e);return i}(e,t)&&(x(e.prev,e,t.prev)||x(e,t.prev,t))||P(e,t)&&x(e.prev,e,e.next)>0&&x(t.prev,t,t.next)>0)}function x(e,t,n){return(t.y-e.y)*(n.x-t.x)-(t.x-e.x)*(n.y-t.y)}function P(e,t){return e.x===t.x&&e.y===t.y}function m(e,t,n,i){var o=L(x(e,t,n)),r=L(x(e,t,i)),s=L(x(n,i,e)),a=L(x(n,i,t));return o!==r&&s!==a||(!(0!==o||!b(e,n,t))||(!(0!==r||!b(e,i,t))||(!(0!==s||!b(n,e,i))||!(0!==a||!b(n,t,i)))))}function b(e,t,n){return t.x<=Math.max(e.x,n.x)&&t.x>=Math.min(e.x,n.x)&&t.y<=Math.max(e.y,n.y)&&t.y>=Math.min(e.y,n.y)}function L(e){return e>0?1:e<0?-1:0}function C(e,t){return x(e.prev,e,e.next)<0?x(e,t,e.next)>=0&&x(e,e.prev,t)>=0:x(e,t,e.prev)<0||x(e,e.next,t)<0}function S(e,t){var n=new A(e.i,e.x,e.y),i=new A(t.i,t.x,t.y),o=e.next,r=t.prev;return e.next=t,t.prev=e,n.next=o,o.prev=n,i.next=n,n.prev=i,r.next=i,i.prev=r,i}function w(e,t,n,i){var o=new A(e,t,n);return i?(o.next=i.next,o.prev=i,i.next.prev=o,i.next=o):(o.prev=o,o.next=o),o}function _(e){e.next.prev=e.prev,e.prev.next=e.next,e.prevZ&&(e.prevZ.nextZ=e.nextZ),e.nextZ&&(e.nextZ.prevZ=e.prevZ)}function A(e,t,n){this.i=e,this.x=t,this.y=n,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1}function k(e,t,n,i){for(var o=0,r=t,s=n-i;r<n;r+=i)o+=(e[s]-e[r])*(e[r+1]+e[s+1]),s=r;return o}e.exports=i,e.exports.default=i,i.deviation=function(e,t,n,i){var o=t&&t.length,r=o?t[0]*n:e.length,s=Math.abs(k(e,0,r,n));if(o)for(var a=0,l=t.length;a<l;a++){var c=t[a]*n,u=a<l-1?t[a+1]*n:e.length;s-=Math.abs(k(e,c,u,n))}var p=0;for(a=0;a<i.length;a+=3){var d=i[a]*n,f=i[a+1]*n,v=i[a+2]*n;p+=Math.abs((e[d]-e[v])*(e[f+1]-e[d+1])-(e[d]-e[f])*(e[v+1]-e[d+1]))}return 0===s&&0===p?0:Math.abs((p-s)/s)},i.flatten=function(e){for(var t=e[0][0].length,n={vertices:[],holes:[],dimensions:t},i=0,o=0;o<e.length;o++){for(var r=0;r<e[o].length;r++)for(var s=0;s<t;s++)n.vertices.push(e[o][r][s]);o>0&&(i+=e[o-1].length,n.holes.push(i))}return n}},4759:function(e,t,n){\"use strict\";n.d(t,\"a\",(function(){return y}));var i=n(15),o=n(16),r=n(223),s=n(89),a=n(241),l=n(19),c=n(4740),u=n(4692),p=n(5113),d=n(4890),f=n(4788),v=p.a.fp64LowPart,h=[0,0,0,255],g={radiusScale:{type:\"number\",min:0,value:1},radiusMinPixels:{type:\"number\",min:0,value:0},radiusMaxPixels:{type:\"number\",min:0,value:Number.MAX_SAFE_INTEGER},lineWidthUnits:\"meters\",lineWidthScale:{type:\"number\",min:0,value:1},lineWidthMinPixels:{type:\"number\",min:0,value:0},lineWidthMaxPixels:{type:\"number\",min:0,value:Number.MAX_SAFE_INTEGER},stroked:!1,fp64:!1,filled:!0,getPosition:{type:\"accessor\",value:function(e){return e.position}},getRadius:{type:\"accessor\",value:1},getFillColor:{type:\"accessor\",value:h},getLineColor:{type:\"accessor\",value:h},getLineWidth:{type:\"accessor\",value:1},strokeWidth:{deprecatedFor:\"getLineWidth\"},outline:{deprecatedFor:\"stroked\"},getColor:{deprecatedFor:[\"getFillColor\",\"getLineColor\"]}},y=function(e){function t(){return Object(i.a)(this,t),Object(r.a)(this,Object(s.a)(t).apply(this,arguments))}return Object(l.a)(t,e),Object(o.a)(t,[{key:\"getShaders\",value:function(e){return{vs:\"#define SHADER_NAME scatterplot-layer-vertex-shader\\n\\nattribute vec3 positions;\\n\\nattribute vec3 instancePositions;\\nattribute vec2 instancePositions64xyLow;\\nattribute float instanceRadius;\\nattribute float instanceLineWidths;\\nattribute vec4 instanceFillColors;\\nattribute vec4 instanceLineColors;\\nattribute vec3 instancePickingColors;\\n\\nuniform float opacity;\\nuniform float radiusScale;\\nuniform float radiusMinPixels;\\nuniform float radiusMaxPixels;\\nuniform float lineWidthScale;\\nuniform float lineWidthMinPixels;\\nuniform float lineWidthMaxPixels;\\nuniform float stroked;\\nuniform bool filled;\\n\\nvarying vec4 vFillColor;\\nvarying vec4 vLineColor;\\nvarying vec2 unitPosition;\\nvarying float innerUnitRadius;\\n\\nvoid main(void) {\\n  float outerRadiusPixels = clamp(\\n    project_size_to_pixel(radiusScale * instanceRadius),\\n    radiusMinPixels, radiusMaxPixels\\n  );\\n  float lineWidthPixels = clamp(\\n    project_size_to_pixel(lineWidthScale * instanceLineWidths),\\n    lineWidthMinPixels, lineWidthMaxPixels\\n  );\\n  outerRadiusPixels += stroked * lineWidthPixels / 2.0;\\n  unitPosition = positions.xy;\\n\\n  innerUnitRadius = 1.0 - stroked * lineWidthPixels / outerRadiusPixels;\\n  \\n  vec3 offset = positions * project_pixel_size(outerRadiusPixels);\\n  gl_Position = project_position_to_clipspace(instancePositions, instancePositions64xyLow, offset);\\n  vFillColor = vec4(instanceFillColors.rgb, instanceFillColors.a * opacity) / 255.;\\n  vLineColor = vec4(instanceLineColors.rgb, instanceLineColors.a * opacity) / 255.;\\n  picking_setPickingColor(instancePickingColors);\\n}\\n\",fs:\"#define SHADER_NAME scatterplot-layer-fragment-shader\\n\\nprecision highp float;\\n\\nuniform bool filled;\\n\\nvarying vec4 vFillColor;\\nvarying vec4 vLineColor;\\nvarying vec2 unitPosition;\\nvarying float innerUnitRadius;\\n\\nvoid main(void) {\\n\\n  float distToCenter = length(unitPosition);\\n\\n  if (distToCenter > 1.0) {\\n    discard;\\n  } \\n  if (distToCenter > innerUnitRadius) {\\n    gl_FragColor = vLineColor;\\n  } else if (filled) {\\n    gl_FragColor = vFillColor;\\n  } else {\\n    discard;\\n  }\\n  gl_FragColor = picking_filterHighlightColor(gl_FragColor);\\n  gl_FragColor = picking_filterPickingColor(gl_FragColor);\\n}\\n\",modules:[this.use64bitProjection()?\"project64\":\"project32\",\"picking\"]}}},{key:\"initializeState\",value:function(){this.getAttributeManager().addInstanced({instancePositions:{size:3,transition:!0,accessor:\"getPosition\"},instancePositions64xyLow:{size:2,accessor:\"getPosition\",update:this.calculateInstancePositions64xyLow},instanceRadius:{size:1,transition:!0,accessor:\"getRadius\",defaultValue:1},instanceFillColors:{size:4,transition:!0,type:5121,accessor:\"getFillColor\",defaultValue:[0,0,0,255]},instanceLineColors:{size:4,transition:!0,type:5121,accessor:\"getLineColor\",defaultValue:[0,0,0,255]},instanceLineWidths:{size:1,transition:!0,accessor:\"getLineWidth\",defaultValue:1}})}},{key:\"updateState\",value:function(e){var n=e.props,i=e.oldProps,o=e.changeFlags;if(Object(a.a)(Object(s.a)(t.prototype),\"updateState\",this).call(this,{props:n,oldProps:i,changeFlags:o}),n.fp64!==i.fp64){var r=this.context.gl;this.state.model&&this.state.model.delete(),this.setState({model:this._getModel(r)}),this.getAttributeManager().invalidateAll()}}},{key:\"draw\",value:function(e){var t=e.uniforms,n=this.context.viewport,i=this.props,o=i.radiusScale,r=i.radiusMinPixels,s=i.radiusMaxPixels,a=i.stroked,l=i.filled,c=i.lineWidthUnits,u=i.lineWidthScale,p=i.lineWidthMinPixels,d=i.lineWidthMaxPixels,f=\"pixels\"===c?n.distanceScales.metersPerPixel[2]:1;this.state.model.setUniforms(Object.assign({},t,{stroked:a?1:0,filled:l,radiusScale:o,radiusMinPixels:r,radiusMaxPixels:s,lineWidthScale:u*f,lineWidthMinPixels:p,lineWidthMaxPixels:d})).draw()}},{key:\"_getModel\",value:function(e){return new d.a(e,Object.assign(this.getShaders(),{id:this.props.id,geometry:new f.a({drawMode:6,vertexCount:4,attributes:{positions:{size:3,value:new Float32Array([-1,-1,0,-1,1,0,1,1,0,1,-1,0])}}}),isInstanced:!0,shaderCache:this.context.shaderCache}))}},{key:\"calculateInstancePositions64xyLow\",value:function(e,t){var n=t.startRow,i=t.endRow,o=this.use64bitPositions();if(e.constant=!o,o){var r=this.props,s=r.data,a=r.getPosition,l=e.value,u=n*e.size,p=Object(c.a)(s,n,i),d=p.iterable,f=p.objectInfo,h=!0,g=!1,y=void 0;try{for(var x,P=d[Symbol.iterator]();!(h=(x=P.next()).done);h=!0){var m=x.value;f.index++;var b=a(m,f);l[u++]=v(b[0]),l[u++]=v(b[1])}}catch(e){g=!0,y=e}finally{try{h||null==P.return||P.return()}finally{if(g)throw y}}}else e.value=new Float32Array(2)}}]),t}(u.a);y.layerName=\"ScatterplotLayer\",y.defaultProps=g},4763:function(e,t,n){\"use strict\";n.d(t,\"a\",(function(){return c}));var i=n(15),o=n(223),r=n(89),s=n(29),a=n(19),l={ambient:.35,diffuse:.6,shininess:32,specularColor:[30,30,30]},c=function(e){function t(e){var n;return Object(i.a)(this,t),n=Object(o.a)(this,Object(r.a)(t).call(this,e)),e=Object.assign({},l,e),Object.assign(Object(s.a)(n),e),n}return Object(a.a)(t,e),t}((function e(){Object(i.a)(this,e)}))},4899:function(e,t,n){\"use strict\";n.r(t),n.d(t,\"getLayer\",(function(){return N}));var i=n(0),o=n.n(i),r=n(2),s=n.n(r),a=n(15),l=n(16),c=n(223),u=n(89),p=n(19),d=n(4706),f=n(4759),v=n(4700),h=n(4763),g=n(4718),y=n(4655);function x(e,t,n){var i=e.type,o=e.coordinates,r=t.pointFeatures,s=t.lineFeatures,a=t.polygonFeatures,l=t.polygonOutlineFeatures;if(function(e,t){var n=m[e];y.a.assert(n,\"Unknown GeoJSON type \".concat(e));for(;t&&--n>0;)t=t[0];return t&&Number.isFinite(t[0])}(i,o))switch(i){case\"Point\":r.push({geometry:e,sourceFeature:n});break;case\"MultiPoint\":o.forEach((function(e){r.push({geometry:{type:\"Point\",coordinates:e},sourceFeature:n})}));break;case\"LineString\":s.push({geometry:e,sourceFeature:n});break;case\"MultiLineString\":o.forEach((function(e){s.push({geometry:{type:\"LineString\",coordinates:e},sourceFeature:n})}));break;case\"Polygon\":a.push({geometry:e,sourceFeature:n}),o.forEach((function(e){l.push({geometry:{type:\"LineString\",coordinates:e},sourceFeature:n})}));break;case\"MultiPolygon\":o.forEach((function(e){a.push({geometry:{type:\"Polygon\",coordinates:e},sourceFeature:n}),e.forEach((function(e){l.push({geometry:{type:\"LineString\",coordinates:e},sourceFeature:n})}))}))}else y.a.warn(\"\".concat(i,\" coordinates are malformed\"))()}function P(e){return e.sourceFeature.feature}var m={Point:1,MultiPoint:2,LineString:2,MultiLineString:3,Polygon:3,MultiPolygon:4};var b=new h.a,L={stroked:!0,filled:!0,extruded:!1,wireframe:!1,lineWidthUnits:\"meters\",lineWidthScale:1,lineWidthMinPixels:0,lineWidthMaxPixels:Number.MAX_SAFE_INTEGER,lineJointRounded:!1,lineMiterLimit:4,elevationScale:1,pointRadiusScale:1,pointRadiusMinPixels:0,pointRadiusMaxPixels:Number.MAX_SAFE_INTEGER,lineDashJustified:!1,fp64:!1,getLineColor:{type:\"accessor\",value:[0,0,0,255]},getFillColor:{type:\"accessor\",value:[0,0,0,255]},getRadius:{type:\"accessor\",value:1},getLineWidth:{type:\"accessor\",value:1},getLineDashArray:{type:\"accessor\",value:[0,0]},getElevation:{type:\"accessor\",value:1e3},material:b};function C(e){return e.geometry.coordinates}function S(e){return\"function\"!=typeof e?e:function(t){return e(P(t))}}var w=function(e){function t(){return Object(a.a)(this,t),Object(c.a)(this,Object(u.a)(t).apply(this,arguments))}return Object(p.a)(t,e),Object(l.a)(t,[{key:\"initializeState\",value:function(){this.state={features:{}}}},{key:\"updateState\",value:function(e){e.oldProps;var t=e.props;if(e.changeFlags.dataChanged){var n=function(e){if(Array.isArray(e))return e;switch(y.a.assert(e.type,\"GeoJSON does not have type\"),e.type){case\"Feature\":return[e];case\"FeatureCollection\":return y.a.assert(Array.isArray(e.features),\"GeoJSON does not have features array\"),e.features;default:return[{geometry:e}]}}(t.data);this.state.features=function(e){for(var t={pointFeatures:[],lineFeatures:[],polygonFeatures:[],polygonOutlineFeatures:[]},n=0;n<e.length;n++){var i=e[n];y.a.assert(i&&i.geometry,\"GeoJSON does not have geometry\");var o=i.geometry,r={feature:i,index:n};if(\"GeometryCollection\"===o.type){y.a.assert(Array.isArray(o.geometries),\"GeoJSON does not have geometries array\");for(var s=o.geometries,a=0;a<s.length;a++){x(s[a],t,r)}}else x(o,t,r)}return t}(n)}}},{key:\"getPickingInfo\",value:function(e){var t,n=e.info;e.sourceLayer;return Object.assign(n,{object:n.object?P(n.object):n.object,index:n.object?(t=n.object,t.sourceFeature.index):n.index})}},{key:\"renderLayers\",value:function(){var e=this.state.features,t=e.pointFeatures,n=e.lineFeatures,i=e.polygonFeatures,o=e.polygonOutlineFeatures,r=this.props,s=r.stroked,a=r.filled,l=r.extruded,c=r.wireframe,u=r.material,p=r.transitions,d=this.props,h=d.lineWidthUnits,y=d.lineWidthScale,x=d.lineWidthMinPixels,P=d.lineWidthMaxPixels,m=d.lineJointRounded,b=d.lineMiterLimit,L=d.pointRadiusScale,w=d.pointRadiusMinPixels,_=d.pointRadiusMaxPixels,A=d.elevationScale,k=d.lineDashJustified,E=d.fp64,j=this.props,O=j.getLineColor,M=j.getFillColor,F=j.getRadius,z=j.getLineWidth,T=j.getLineDashArray,R=j.getElevation,I=j.updateTriggers,N=this.getSubLayerClass(\"polygons-fill\",g.a),W=this.getSubLayerClass(\"polygons-stroke\",v.a),B=this.getSubLayerClass(\"line-strings\",v.a),D=this.getSubLayerClass(\"points\",f.a),V=this.shouldRenderSubLayer(\"polygons-fill\",i)&&new N({fp64:E,extruded:l,elevationScale:A,filled:a,wireframe:c,material:u,getElevation:S(R),getFillColor:S(M),getLineColor:S(O),transitions:p&&{getPolygon:p.geometry,getElevation:p.getElevation,getFillColor:p.getFillColor,getLineColor:p.getLineColor}},this.getSubLayerProps({id:\"polygons-fill\",updateTriggers:{getElevation:I.getElevation,getFillColor:I.getFillColor,getLineColor:I.getLineColor}}),{data:i,getPolygon:C});return[!l&&V,!l&&s&&this.shouldRenderSubLayer(\"polygons-stroke\",o)&&new W({fp64:E,widthUnits:h,widthScale:y,widthMinPixels:x,widthMaxPixels:P,rounded:m,miterLimit:b,dashJustified:k,getColor:S(O),getWidth:S(z),getDashArray:S(T),transitions:p&&{getPath:p.geometry,getColor:p.getLineColor,getWidth:p.getLineWidth}},this.getSubLayerProps({id:\"polygons-stroke\",updateTriggers:{getColor:I.getLineColor,getWidth:I.getLineWidth,getDashArray:I.getLineDashArray}}),{data:o,getPath:C}),this.shouldRenderSubLayer(\"linestrings\",n)&&new B({fp64:E,widthUnits:h,widthScale:y,widthMinPixels:x,widthMaxPixels:P,rounded:m,miterLimit:b,dashJustified:k,getColor:S(O),getWidth:S(z),getDashArray:S(T),transitions:p&&{getPath:p.geometry,getColor:p.getLineColor,getWidth:p.getLineWidth}},this.getSubLayerProps({id:\"line-strings\",updateTriggers:{getColor:I.getLineColor,getWidth:I.getLineWidth,getDashArray:I.getLineDashArray}}),{data:n,getPath:C}),this.shouldRenderSubLayer(\"points\",t)&&new D({fp64:E,stroked:s,filled:a,radiusScale:L,radiusMinPixels:w,radiusMaxPixels:_,lineWidthUnits:h,lineWidthScale:y,lineWidthMinPixels:x,lineWidthMaxPixels:P,getFillColor:S(M),getLineColor:S(O),getRadius:S(F),getLineWidth:S(z),transitions:p&&{getPosition:p.geometry,getFillColor:p.getFillColor,getLineColor:p.getLineColor,getRadius:p.getRadius,getLineWidth:p.getLineWidth}},this.getSubLayerProps({id:\"points\",updateTriggers:{getFillColor:I.getFillColor,getLineColor:I.getLineColor,getRadius:I.getRadius,getLineWidth:I.getLineWidth}}),{data:t,getPosition:C}),l&&V]}}]),t}(d.a);w.layerName=\"GeoJsonLayer\",w.defaultProps=L;var _=n(4661),A=n(4677),k=n(4658),E=n(4664),j=n(4665);function O(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function M(){return(M=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var i in n)Object.prototype.hasOwnProperty.call(n,i)&&(e[i]=n[i])}return e}).apply(this,arguments)}const F={fillColor:\"fillColor\",color:\"fillColor\",fill:\"fillColor\",\"fill-color\":\"fillColor\",strokeColor:\"strokeColor\",\"stroke-color\":\"strokeColor\",\"stroke-width\":\"strokeWidth\"},z=(e,t)=>{const n={};return Object.keys(e).forEach(t=>{t in F?n[F[t]]=e[t]:n[t]=e[t]}),\"string\"==typeof e.fillColor&&(n.fillColor=Object(A.hexToRGB)(e.fillColor)),\"string\"==typeof e.strokeColor&&(n.strokeColor=Object(A.hexToRGB)(e.strokeColor)),M({},n,{},t)};let T;const R=(e,t,n)=>{if(e&&e.features&&e.features.forEach(i=>{R(i,t,e.extraProps||n)}),e&&e.geometry){const i=M({},e,{properties:z(e.properties,t)});i.extraProps||(i.extraProps=n),T.push(i)}};function I(e){return e.object.extraProps&&o.a.createElement(\"div\",{className:\"deckgl-tooltip\"},Object.keys(e.object.extraProps).map((t,n)=>o.a.createElement(j.a,{key:\"prop-\"+n,label:t+\": \",value:\"\"+e.object.extraProps[t]})))}function N(e,t,n,i){const o=e,r=o.fill_color_picker,s=o.stroke_color_picker,a=[r.r,r.g,r.b,255*r.a],l=[s.r,s.g,s.b,255*s.a],c={};let u;return a[3]>0&&(c.fillColor=a),l[3]>0&&(c.strokeColor=l),T=[],R(t.data,c),o.js_data_mutator&&(u=Object(k.a)(o.js_data_mutator),T=u(T)),new w(M({id:\"geojson-layer-\"+o.slice_id,filled:o.filled,data:T,stroked:o.stroked,extruded:o.extruded,pointRadiusScale:o.point_radius_scale},Object(E.a)(o,i,I)))}const W={formData:s.a.object.isRequired,payload:s.a.object.isRequired,setControlValue:s.a.func.isRequired,viewport:s.a.object.isRequired,onAddFilter:s.a.func},B={onAddFilter(){}};class D extends o.a.Component{constructor(){super(...arguments),O(this,\"containerRef\",o.a.createRef()),O(this,\"setTooltip\",e=>{const{current:t}=this.containerRef;t&&t.setTooltip(e)})}render(){const{formData:e,payload:t,setControlValue:n,onAddFilter:i,viewport:r}=this.props,s=N(e,t,0,this.setTooltip);return o.a.createElement(_.a,{ref:this.containerRef,mapboxApiAccessToken:t.data.mapboxApiKey,viewport:r,layers:[s],mapStyle:e.mapbox_style,setControlValue:n})}}D.propTypes=W,D.defaultProps=B;t.default=D}}]);","extractedComments":[]}